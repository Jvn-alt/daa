<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DAA Programs</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <style>
  body {
    font-family: Consolas, Menlo, monospace;
    background: #f9f9f9;
    color: #222;
    padding: 20px;
    margin: 0;
    transition: background 0.3s ease, color 0.3s ease;
  }

  h1 {
    text-align: center;
    font-size: 2rem;
    font-weight: 600;
    margin-bottom: 20px;
  }

  .program {
    background: #f4f4f4;
    color: #000;
    border: 1px solid #ccc;
    padding: 15px;
    margin-bottom: 30px;
    white-space: pre-wrap;
    overflow-x: auto;
    font-family: Consolas, Menlo, monospace;
    font-size: 14px;
  }

  summary {
    font-size: 1.1rem;
    font-weight: bold;
    cursor: pointer;
    margin-bottom: 10px;
  }

  .theme-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    cursor: pointer;
    background: #444;
    color: #fff;
    border: none;
    border-radius: 4px;
    font-size: 12px;
  }

  body.dark {
    background: #121212;
    color: #ddd;
  }

  body.dark .program {
    background: #1e1e1e;
    color: #eee;
    border-color: #444;
  }

  code, pre {
    font-family: Consolas, Menlo, monospace;
    font-size: 14px;
    background-color: inherit;
    color: inherit;
  }

  * {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  </style>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />
</head>
<body>

<button class="theme-toggle" onclick="toggleTheme()">Toggle Dark Mode</button>
<h1>DAA Programs</h1>

<details open>
  <summary>1. Linear Search</summary>
  <div class="program">
    <pre><code class="language-python">
import time
import matplotlib.pyplot as plt

# Linear search implementation
def linear_search(arr, n, key):
    for i in range(n):
        if arr[i] == key:
            return i
    return -1

# Run and time the search
def linear_key(r):
    results = []
    for _ in range(r):
        n = int(input('Enter number of elements: '))
        arr = list(map(int, input('Enter array: ').split()))
        key = int(input('Enter key: '))
        start = time.time()
        for _ in range(10000):
            linear_search(arr, n, key)
        end = time.time()
        print('Time taken:', (end - start) * 1000, 'ms')
        results.append((n, (end - start) * 1000))
    return results

# Plotting results
def plot_results(results):
    n_vals, times = zip(*results)
    plt.plot(n_vals, times, 'gD--')
    plt.xlabel('Elements')
    plt.ylabel('Time (ms)')
    plt.title('Linear Search Complexity')
    plt.grid(True)
    plt.show()
    </code></pre>
  </div>
</details>

<details open>
  <summary>2. Tower Of Hannoi</summary>
  <div class="program">
    <pre><code class="language-python">
def TowerOfHanoi(n, source, destination, auxiliary):
    if n == 1:
        print("Move disk 1 from source", source, "to destination", destination)
        return
    TowerOfHanoi(n - 1, source, auxiliary, destination)
    print("Move disk", n, "from source", source, "to destination", destination)
    TowerOfHanoi(n - 1, auxiliary, destination, source)

n = int(input("Enter the number of disks: "))
TowerOfHanoi(n, 'A', 'B', 'C')
</code></pre>
  </div>
</details>

<details open>
  <summary>3. Binary Search</summary>
  <div class="program">
    <pre><code class="language-python">
import time
import matplotlib.pyplot as plt

def binary_search(arr, low, high, key):
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            low = mid + 1
        else:
            high = mid - 1
    return -1

def main():
    print("Program name: Binary Search algorithm")
    n_values = []
    times = []
    r = int(input("Enter the number of runs: "))
    
    for _ in range(r):
        n = int(input("Enter the number of elements: "))
        arr = sorted(list(map(int, input("Enter the elements of an array: ").split())))
        key = int(input("Enter the key element to be searched: "))
        
        repeat = 10000
        start = time.time()
        
        for _ in range(repeat):
            result = binary_search(arr, 0, n - 1, key)
        
        end = time.time()
        
        if result != -1:
            print(f"Key {key} found at position {result}")
        else:
            print(f"Key {key} not found")
        
        time_taken = (end - start) * 1000
        print(f"Time taken to search a key element = {time_taken} milliseconds\n")
        
        n_values.append(n)
        times.append(time_taken)
    
    plt.figure()
    plt.plot(n_values, times, 'o-')
    plt.xlabel('Number of elements (n)')
    plt.ylabel('Time taken (milliseconds)')
    plt.title('Binary Search Time Complexity')
    plt.grid(True)
    plt.show()
          
if __name__ == "__main__":
    main()
</code></pre>
  </div>
</details>

<details open>
  <summary>4. Brute Force</summary>
  <div class="program">
    <pre><code class="language-python">
def power_bruteforce(a, n):
    result = 1
    for i in range(n):
        result *= a
    return result

def power_divide_conquer(a, n):
    if n == 0:
        return 1
    elif n % 2 == 0:
        return power_divide_conquer(a * a, n // 2)
    else:
        return a * power_divide_conquer(a * a, n // 2)

a, n = map(int, input("Enter the value of a and n: ").split())

result_brut = power_bruteforce(a, n)
result_divide_conquer = power_divide_conquer(a, n)

print("Result using brute force:", result_brut)
print("Result using divide and conquer:", result_divide_conquer)
</code></pre>
  </div>
</details>
  
<details open>
  <summary>5. Selection Sort</summary>
  <div class="program">
    <pre><code class="language-python">

import timeit
import random
import matplotlib.pyplot as plt

def Input(Array, n):
    for i in range(0, n):  # Fixed typo
        ele = random.randrange(0, 50)  # Use a fixed range for better randomness
        Array.append(ele)

def Selectionsort(Array, size):
    for ind in range(size):
        min_index = ind
        for j in range(ind + 1, size):
            if Array[j] < Array[min_index]:
                min_index = j
        # Swap elements to sort
        Array[ind], Array[min_index] = Array[min_index], Array[ind]

n_values = []  # Store different values of n (array sizes)
CPU_times = []  # Store CPU times

trials = int(input("Enter number of trials: "))  # Fixed typo here from "trail" to "trials"

for t in range(trials):
    Array = []
    print(f"-------->TRIAL NUMBER: {t + 1}")
    n = int(input("Enter number of elements: "))
    Input(Array, n)

    start_time = timeit.default_timer()  # Record start time
    Selectionsort(Array, n)
    end_time = timeit.default_timer()  # Record end time

    elapsed_time = end_time - start_time  # Calculate elapsed time
    print("Sorted array:")
    print(Array)

    n_values.append(n)  # Append n to the list
    CPU_times.append(round(elapsed_time * 1000000, 2))  # Convert to microseconds

# Print results
print("N CPU Time (in microseconds):")
for i in range(trials):
    print(f"{n_values[i]} {CPU_times[i]}")

# Plotting the graph
plt.plot(n_values, CPU_times)
plt.scatter(n_values, CPU_times, color="red", marker="*", s=100)
plt.xlabel("Array Size (N)")
plt.ylabel("CPU Processing Time (Microseconds)")
plt.title("Selection Sort CPU Time vs Array Size")
plt.show()
</code></pre>
  </div>
</details>
  
<details open>
  <summary>6. Quick Sort</summary>
  <div class="program">
    <pre><code class="language-python">

import time
import random
import matplotlib.pyplot as plt

def Input(Array, n):
    for i in range(0, n):
        ele = random.randrange(1, 50)
        Array.append(ele)

def partition(Array, low, high):
    i = (low - 1)
    pivot = Array[high]

    for j in range(low, high):
        if Array[j] <= pivot:
            i = i + 1
            Array[i], Array[j] = Array[j], Array[i]

    Array[i + 1], Array[high] = Array[high], Array[i + 1]
    return (i + 1)

def QuickSort(Array, low, high):
    if low < high:
        pi = partition(Array, low, high)
        QuickSort(Array, low, pi - 1)
        QuickSort(Array, pi + 1, high)

N = []
CPU = []
trail = int(input("Enter no of trials: "))

for t in range(0, trail):
    Array = []
    print("\n--- Trial No:", t + 1, "---")
    n = int(input("Enter no of elements: "))
    Input(Array, n)

    start = time.process_time()
    QuickSort(Array, 0, n - 1)
    times = time.process_time() - start

    print("Sorted Array:")
    print(Array)
    N.append(n)
    CPU.append(round(float(times) * 1000000, 2))

print("\nN | CPU")
for t in range(0, trail):
    print(N[t], "|", CPU[t])

plt.plot(N,CPU)

plt.scatter(N, CPU, color="red", marker="x", s=50)
plt.xlabel("Array size = N")
plt.ylabel("CPU Processing time")
plt.title("Quick Sort time efficiency")
plt.show()
</code></pre>
  </div>
</details>

<details open>
  <summary>7. Binomial Coeff</summary>
  <div class="program">
    <pre><code class="language-python">
def factorial(n):
    fact = 1
    for i in range(1, n + 1):
        fact = fact * i
    return fact

def binomialCoeff_brutoforce(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

def binomialCoeff_DP(n, k):
    c = [[0 for j in range(k + 1)] for i in range(n + 1)]
    for i in range(n + 1):
        for j in range(min(i, k) + 1):
            if j == 0 or j == i:
                c[i][j] = 1
            else:
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j]
    return c[n][k]

n = int(input("Enter the value of n: "))
k = int(input("Enter the value of k: "))
result_bruteForce = binomialCoeff_brutoforce(n, k)
result_DP = binomialCoeff_DP(n, k)
print(f"Binomial Coefficient (Brute Force): {result_bruteForce}")
print(f"Binomial Coefficient (Dynamic Programming): {result_DP}")
</code></pre>
  </div>
</details>

<details open>
  <summary>8. BFS</summary>
  <div class="program">
    <pre><code class="language-python">
Max = 100
c = [[0] * Max for _ in range(Max)]
visited = [0] * Max
queue = [0] * Max

def BFS(v):
    front = 0
    rear = -1

    visited[v] = 1
    queue[rear + 1] = v
    rear += 1

    while front <= rear:
        v = queue[front]
        front += 1

        print(f"{v}", end=" ")

        for i in range(1, n + 1):
            if c[v][i] == 1 and visited[i] == 0:
                queue[rear + 1] = i
                rear += 1
                visited[i] = 1

if __name__ == "__main__":
    print("Enter the no. of vertices in the graph:")
    n = int(input())

    print("Enter the cost matrix of the graph:")
    for i in range(1, n + 1):
        c[i] = [0] + list(map(int, input().split()))

    for i in range(1, n + 1):
        visited[i] = 0

    print("Enter the starting vertex:")
    v = int(input())

    print("BFS traversal of the graph is:", end=" ")
    BFS(v)
</code></pre>
  </div>
</details>

<details open>
  <summary>9. Polynomial (Brute Force) </summary>
  <div class="program">
    <pre><code class="language-python">
import time
import math

def bruteForce(coeff, n, x):
    sum = 0.0
    for i in range(0, n + 1):
        sum = sum + coeff[i] * math.pow(x, i)
    return sum

def hornersRule(coeff, n, x):
    result = coeff[n]
    for i in range(n - 1, -1, -1):
        result = result * x + coeff[i]
    return result

n = int(input("Enter the degree of the polynomial: "))

coeff = [0] * (n + 1)
print("Enter the coefficients from highest to lowest degree:")
for i in range(n, -1, -1):
    coeff[i] = int(input())

x = float(input("Enter the value of x: "))

start = time.time()
brute_force_result = bruteForce(coeff, n, x)
end = time.time()
time_used = end - start
print(f"Brute force result: {brute_force_result}; Time used: {time_used} seconds")

start = time.time()
horners_rule_result = hornersRule(coeff, n, x)
end = time.time()
time_used = end - start
print(f"Horner's rule result: {horners_rule_result}; Time used: {time_used} seconds")
</code></pre>
  </div>
</details>

<details open>
  <summary>10. Minimum Spanning Tree (Prince Algorithm) </summary>
  <div class="program">
    <pre><code class="language-python">
import sys

def minKey(key, mstSet, n):
    min_value = sys.maxsize
    for v in range(n):
        if mstSet[v] == False and key[v] < min_value:
            min_value = key[v]
            min_index = v
    return min_index

def printMST(parent, c, n):
    total_weight = 0
    print("Edge \tWeight")
    for i in range(1, n):
        print(str(parent[i]) + " - " + str(i) + " \t" + str(c[i][parent[i]]))
        total_weight += c[i][parent[i]]
    return total_weight

def primMST(c, n):
    parent = [None] * n
    key = [sys.maxsize] * n
    mstSet = [False] * n

    key[0] = 0
    parent[0] = -1

    for count in range(n):
        u = minKey(key, mstSet, n)
        mstSet[u] = True

        for v in range(n):
            if c[u][v] > 0 and mstSet[v] == False and c[u][v] < key[v]:
                key[v] = c[u][v]
                parent[v] = u

    total_weight = printMST(parent, c, n)
    print("Total cost of the minimum spanning tree: " + str(total_weight))

# Driver code
n = int(input("Enter no. of vertices: "))
c = []

print("Enter the cost adjacency matrix:")
for i in range(n):
    c.append(list(map(int, input().split())))

primMST(c, n)

</code></pre>
  </div>
</details>

<details open>
  <summary>11. String Matching (Boyer-moore) </summary>
  <div class="program">
    <pre><code class="language-python">

def computeLPSArray(pat, M, lps):
    length = 0  # length of the previous longest prefix suffix
    lps[0] = 0  # lps[0] is always 0
    i = 1

    while i < M:
        if pat[i] == pat[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1

def KMPSearch(pat, txt):
    M = len(pat)
    N = len(txt)
    lps = [0] * M
    computeLPSArray(pat, M, lps)

    i = j = 0  # index for txt[], index for pat[]
    while i < N:
        if pat[j] == txt[i]:
            i += 1
            j += 1

        if j == M:
            print(f"Found pattern at index {i - j}")
            j = lps[j - 1]
        elif i < N and pat[j] != txt[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1


txt = input("Enter the text: ")
pat = input("Enter the pattern: ")
KMPSearch(pat, txt)
</code></pre>
  </div>
</details>

<details open>
  <summary>12. String Matching (KMP Algorithm) </summary>
  <div class="program">
    <pre><code class="language-python">
MAX_CHARS = 256

def max(a, b):
    return a if a > b else b

def badCharHeuristic(pat, size, badchar):
    for i in range(MAX_CHARS):
        badchar[i] = -1
    for i in range(size):
        badchar[ord(pat[i])] = i

def patternsearch(text, pat):
    m = len(pat)
    n = len(text)
    badchar = [-1] * MAX_CHARS

    badCharHeuristic(pat, m, badchar)

    s = 0  # s is shift of the pattern with respect to text
    while s <= (n - m):
        j = m - 1

        while j >= 0 and pat[j] == text[s + j]:
            j = j - 1

        if j < 0:
            print("\nPattern occurs at position = ", s)
            s += m - badchar[ord(text[s + m])] if (s + m) < n else 1
        else:
            s += max(1, j - badchar[ord(text[s + j])])


text = input("Enter the text: ").rstrip('\n')
pat = input("Enter the pattern: ").rstrip('\n')

patternsearch(text, pat)
</code></pre>
  </div>
</details>

  <details open>
  <summary>13(a). Topological Ordering</summary>
  <div class="program">
    <pre><code class="language-python">
def main():
    n = int(input("Enter the number of vertices: "))
    count = 0
    c = [[0 for _ in range(n)] for _ in range(n)]  # Adjacency matrix
    indeg = [0] * n  # In-degree array
    flag = [0] * n   # Processed flag
    i,j,k = 0,0,0
    
    print("Enter the cost matrix (row by row):")
    for i in range(n):
        row = input().split()
        for j in range(n):
            c[i][j] = int(row[j])
    for i in range (n):
        for j in range (n):
            indeg[i] += c[j][i]

    print("Topological Order:")
    while count < n:
        for k in range(n):
            if indeg[k] == 0 and flag[k] == 0:
                print(f"{k+1:3}", end=" ")
                flag[k] = 1
                count += 1
                for i in range(n):
                    if c[k][i] == 1:
                        indeg[i] -= 1
    return 0

if __name__ == "__main__":
    main()

   </code></pre>
  </div>
</details>
  
<details open>
  <summary>13(b). Transitive Closure (Warshal)</summary>
  <div class="program">
    <pre><code class="language-python">
def warshall(c, n):
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if c[i][j] or (c[i][k] and c[k][j]):
                    c[i][j] = 1

    print("The transitive closure of the graph is:")
    for i in range(n):
        for j in range(n):
            print(c[i][j], end=" ")
        print()

def main():
    n = int(input("Enter n: "))
    c = []
    print("Enter adjacency cast matrix:")
    for i in range(n):
        row = list(map(int, input().split()))
        c.append(row)

    warshall(c, n)
main()

  </code></pre>
  </div>
</details>
  <details open>
    
  <summary>14. Floyd's algorithm</summary> 
  <div class="program">
    <pre><code class="language-python">  
INF = 999

# Print the solution matrix
def printSolution(V, D):
    print("The following matrix shows the shortest distances between every pair of vertices")
    for i in range(V):
        for j in range(V):
            if D[i][j] == INF:
                print("%7s" % "INF", end="")
            else:
                print("%3d" % D[i][j], end=" ")
        print()

# Implementing Floyd Warshall Algorithm
def floyd(V, C):
    D = [[0] * V for _ in range(V)]

    for i in range(V):
        for j in range(V):
            D[i][j] = C[i][j]

    for k in range(V):
        for i in range(V):
            for j in range(V):
                if D[i][j] > (D[i][k] + D[k][j]):
                    D[i][j] = D[i][k] + D[k][j]

    printSolution(V, D)

# Main Code
V = int(input("Enter the number of vertices: "))

# Allocate memory for the cost matrix
C = [[0] * V for _ in range(V)]

print("Enter the cost matrix row by row (space-separated):")
print("[Enter 999 for Infinity]")
print("[Enter 0 for cost (i,i)]")

for i in range(V):
    C[i] = list(map(int, input().split()))

floyd(V, C) 
    </code></pre>
  </div>
</details>  
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script>
  function toggleTheme() {
    document.body.classList.toggle('dark');
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>

<script>
  document.querySelectorAll('pre').forEach((pre) => {
    const btn = document.createElement('button');
    btn.innerText = 'Copy';
    btn.style.position = 'absolute';
    btn.style.right = '10px';
    btn.style.top = '10px';
    btn.style.padding = '5px 10px';
    btn.style.border = 'none';
    btn.style.background = '#4caf50';
    btn.style.color = 'white';
    btn.style.cursor = 'pointer';
    btn.style.borderRadius = '4px';
    btn.style.fontSize = '12px';

    pre.style.position = 'relative';
    pre.appendChild(btn);

    btn.addEventListener('click', () => {
      navigator.clipboard.writeText(pre.innerText).then(() => {
        btn.innerText = 'Copied!';
        setTimeout(() => (btn.innerText = 'Copy'), 2000);
      });
    });
  });
</script>
      
</body>
</html>
              
